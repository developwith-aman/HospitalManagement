package com.springboot.project.repository;

import com.springboot.project.dto.BloodGroupCount;

import com.springboot.project.entity.Patient;
import com.springboot.project.entity.bloodType.BloodGroups;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Repository
public interface PatientRepository extends JpaRepository<Patient, Long> {

    Patient findByPatientName(String patientName); // this findByPatientName() method is not given by the JpaRepository
    // Custom finder method generated by Spring Data JPA based on naming convention.
    // `findByPatientName` is not predefined in JpaRepository; Spring parses the method name,
    // matches `PatientName` to the entity's `patientName` property, and automatically builds the query.
    // Works as long as the property name matches a field in the entity.
    // If the property name doesn't match, then the error will be show


    // We can use '@Query' to define a custom JPQL query explicitly.
    // Spring Data derives queries from method names if property names match the entity fields.
    // If property names don't match or the query is complex, @Query is used,
    // Here the 'Patient' is not being taken from the database, it's from the Entity class
    // And p.bloodGroup refers to the entity field, not the column name in the database
    @Query("SELECT p FROM Patient p WHERE p.bloodGroup =:group")
    List<Patient> findByBloodGroup(@Param("group") BloodGroups group);


    // Fetching the Blood Group with its count
    // we are using the Object type here, because we will not get the single data, we'll get the object or multiple data
    @Query("SELECT p.bloodGroup, COUNT(p) FROM Patient p GROUP BY p.bloodGroup")
    List<Object[]> countBloodGroupType();
    // The better way to use this ↑ is by using the 'Projection'

    // Doing this ↑ same using Projection here ↓, Projection only works with the JPQL not with the native query
    /** A projection means selecting only specific fields (or a transformed view) from an entity
     instead of fetching the whole entity. */
    // This query uses a JPQL constructor expression to map results into the DTO (BloodGroupCount here).
    // Ensure that BloodGroupCount has a matching constructor (BloodGroups bloodGroup, Long count).
    @Query("SELECT new com.springboot.project.dto.BloodGroupCount(p.bloodGroup, " +
            "Count(p)) from Patient p GROUP BY p.bloodGroup ")
    List<BloodGroupCount> countBloodGroupByProjection();
    // ↑ Fetches only the required fields (bloodGroup and count) using a JPQL constructor expression,
    // instead of retrieving entire Patient entities.


    // Native SQL query
//    @Query(value = "SELECT * FROM patient", nativeQuery = true)
//    List<Patient> allPatients();

    /**
     * The above ↑ method is not inside the controller, it's just for the example purpose that how the native query works
     * By default the value of 'nativeQuery' is 'false' but we've changed it to true,
     * so that the JPA take it as a native SQL query
     */

    @Modifying    // These annotations are necessary
    @Transactional
    @Query(value = "UPDATE patient SET email = :updateEmail WHERE patientID = :id ", nativeQuery = true)
    int updatePatientEmailById(@Param("id") Long id, @Param("updateEmail") String updateEmail);


    // Using Pagination here to fetch the paged data(not the entire data from the database)
    @Query(value = "SELECT * FROM patient", nativeQuery = true)
    Page<Patient> fetchPagedPatients(Pageable pageable);


    /**
     * JpaRepository<T, ID> takes two generics:
     * 1) T  -> The Entity class that maps to your database table (here: Patient)
     * 2) ID -> The type of the primary key (@Id field) of that entity (here: Long)
     * So this interface will automatically provide all CRUD methods for the Patient entity,
     * where the primary key is of type Long.
     **/

}
